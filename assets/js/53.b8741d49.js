(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{548:function(t,s,e){"use strict";e.r(s);var a=e(4),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("ol",[e("li",[t._v("父子通信")]),t._v(" "),e("li",[t._v("兄弟通信")]),t._v(" "),e("li",[t._v("跨级通信")])])]),t._v(" "),e("blockquote",[e("p",[t._v("组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用")])]),t._v(" "),e("h2",{attrs:{id:"props-emit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#props-emit"}},[t._v("#")]),t._v(" "),e("code",[t._v("props/$emit")])]),t._v(" "),e("p",[t._v("父组件向子组件传值: "),e("code",[t._v("props")]),t._v("\n子组件向父组件传值（以事件的形式）: "),e("code",[t._v("$emit")])]),t._v(" "),e("h2",{attrs:{id:"事件总线"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件总线"}},[t._v("#")]),t._v(" 事件总线")]),t._v(" "),e("p",[t._v("通过一个空的 Vue 实例作为中央事件总线，用它来触发和监听事件")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" EventBus "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nEventBus"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("$emit")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("事件名"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 数据"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nEventBus"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("$on")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("事件名"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("data")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[t._v("项目笔记大时，可以通过状态管理解决方案 vuex")]),t._v(" "),e("h2",{attrs:{id:"vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" Vuex")]),t._v(" "),e("p",[t._v("Vuex 实现了单向数据流，在全局拥有一个 State 存放数据，要更改数据必须通过 Mutation，而异步操作必须通过 Action，Action 也是通过 Mutation 来修改 State 的，最后根据 State 的变化，渲染到视图上")]),t._v(" "),e("h2",{attrs:{id:"attrs-listeners"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#attrs-listeners"}},[t._v("#")]),t._v(" $attrs/$listeners")]),t._v(" "),e("p",[e("code",[t._v("$attrs")]),t._v(" 包含父作用域中不被 prop 所识别（且获取）的特性绑定（class、style 除外），可以通过 "),e("code",[t._v("v-bind=$attrs")]),t._v(" 传入内部组件，通常配合 "),e("code",[t._v("inheritAttrs")]),t._v(" 使用，"),e("strong",[t._v("父组件中绑定的非 props 属性")])]),t._v(" "),e("p",[e("code",[t._v("$listeners")]),t._v(" 包含父作用域中不含 "),e("code",[t._v(".native")]),t._v(" 修饰的 v-on 事件监听器，可以通过 "),e("code",[t._v("v-on=$listeners")]),t._v(" 传入内部组件，"),e("strong",[t._v("父组件中绑定的非原生事件")])]),t._v(" "),e("h2",{attrs:{id:"provide-inject"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#provide-inject"}},[t._v("#")]),t._v(" provide/inject")]),t._v(" "),e("p",[t._v("需一起使用，允许一个组件向子孙后代注入一个依赖，主要解决了跨组件通信问题")]),t._v(" "),e("p",[t._v("provide 和 inject 绑定并不是可响应的，但是如果是可监听的对象，那么其属性是可响应的")]),t._v(" "),e("p",[t._v("可以使用 "),e("code",[t._v("Vue.observable")]),t._v(" 来优化响应式 provide")]),t._v(" "),e("h2",{attrs:{id:"parent-children-与-ref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parent-children-与-ref"}},[t._v("#")]),t._v(" $parent/$children 与 ref")]),t._v(" "),e("p",[e("code",[t._v("$parent/$children")]),t._v(" 访问父/子实例")]),t._v(" "),e("p",[e("code",[t._v("ref")]),t._v(" 在普通 DOM 上使用则引用指向 DOM，若用在子组件上，引用指向子组件实例")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("父子通信: 父 -> 子 "),e("code",[t._v("props")]),t._v("，子 -> 父 "),e("code",[t._v("$emit")]),t._v("，"),e("code",[t._v("$parent/$children")]),t._v("，"),e("code",[t._v("ref")]),t._v("，"),e("code",[t._v("provide/inject")]),t._v("，"),e("code",[t._v("$attrs/$listeners")])]),t._v(" "),e("p",[t._v("兄弟通信: EventBus，Vuex")]),t._v(" "),e("p",[t._v("跨级通信：EventBus，Vuex，"),e("code",[t._v("provide/inject")]),t._v("，"),e("code",[t._v("$attrs/$listeners")])])])}),[],!1,null,null,null);s.default=n.exports}}]);