(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{586:function(v,_,a){"use strict";a.r(_);var e=a(4),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("ol",[a("li",[v._v("webpack 优化")]),v._v(" "),a("li",[v._v("webpack 输出分析")])])]),v._v(" "),a("h2",{attrs:{id:"缩小文件搜索范围"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缩小文件搜索范围"}},[v._v("#")]),v._v(" 缩小文件搜索范围")]),v._v(" "),a("p",[v._v("遇到导入语句时")]),v._v(" "),a("ul",[a("li",[v._v("寻找导入对应的文件")]),v._v(" "),a("li",[v._v("根据文件后缀，选择对应 loader 去解析")])]),v._v(" "),a("p",[v._v("尽量减少上述两件事的发生，加快构建")]),v._v(" "),a("h3",{attrs:{id:"优化-loader-配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化-loader-配置"}},[v._v("#")]),v._v(" 优化 loader 配置")]),v._v(" "),a("p",[v._v("使用 "),a("code",[v._v("test")]),v._v(" "),a("code",[v._v("include")]),v._v(" "),a("code",[v._v("exclude")]),v._v(" 三个配置来命中 loader 要应用规则的文件")]),v._v(" "),a("h3",{attrs:{id:"优化-resolve-modules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化-resolve-modules"}},[v._v("#")]),v._v(" 优化 resolve.modules")]),v._v(" "),a("p",[v._v("默认是一层一层往上查找 "),a("code",[v._v("node_modules")]),v._v(" 的第三方模块，可以直接指明在当前根目录下的 "),a("code",[v._v("node_modules")])]),v._v(" "),a("h3",{attrs:{id:"优化-resolve-mainfields"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化-resolve-mainfields"}},[v._v("#")]),v._v(" 优化 resolve.mainFields")]),v._v(" "),a("p",[v._v("用于配置第三方文件的入口，"),a("code",[v._v("target")]),v._v(" 为 "),a("code",[v._v("web")]),v._v(" 或 "),a("code",[v._v("webworker")]),v._v("时，为 "),a("code",[v._v('["browser", "module", "main"]')]),v._v("，其它情况为 "),a("code",[v._v('["module", "main"]')]),v._v("，为减少搜索步骤，可以指明入口文件描述字段")]),v._v(" "),a("h3",{attrs:{id:"优化-resolve-alias"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化-resolve-alias"}},[v._v("#")]),v._v(" 优化 resolve.alias")]),v._v(" "),a("p",[v._v("通过别名来把原路径映射为新的导入路径，减少耗时的递归操作，会影响 tree shaking，需要完整文件的库可以使用此方法如 React，Vue 等，工具类库不使用此方法如 lodash 等")]),v._v(" "),a("h3",{attrs:{id:"优化-resolve-extensions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化-resolve-extensions"}},[v._v("#")]),v._v(" 优化 resolve.extensions")]),v._v(" "),a("p",[v._v("导入语句没带后缀时 webpack 会尝试加上后缀去询问文件，默认为 "),a("code",[v._v('["js", "json"]')])]),v._v(" "),a("p",[v._v("列表越长，越正确的在后面，尝试次数越多")]),v._v(" "),a("ul",[a("li",[v._v("后缀尝试列表要尽可能的小")]),v._v(" "),a("li",[v._v("频率高的放最前面")]),v._v(" "),a("li",[v._v("写导入语句时尽量加上后缀")])]),v._v(" "),a("h3",{attrs:{id:"优化-module-noparse"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化-module-noparse"}},[v._v("#")]),v._v(" 优化 module.noParse")]),v._v(" "),a("p",[v._v("可以让 webpack 忽略部分没采用模块化的文件的递归解析处理，提高构建性能，例如 JQuery， ChartJS，庞大又没有采用模块化规范，此类文件做解析没有意义")]),v._v(" "),a("h2",{attrs:{id:"dllplugin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dllplugin"}},[v._v("#")]),v._v(" DllPlugin")]),v._v(" "),a("p",[v._v("动态链接库，包含给其他模块调用和使用的数据")]),v._v(" "),a("ul",[a("li",[v._v("把网页依赖的基础模块抽离出来，打包到动态链接库中，可以包含多个模块")]),v._v(" "),a("li",[v._v("当需要导入的模块在动态链接库中时，该模块不能在再次打包，去向动态链接库获取")]),v._v(" "),a("li",[v._v("页面依赖的所有动态链接库需要被加载")])]),v._v(" "),a("p",[v._v("加快构建的原因是复用的模块只用编译构建一次，之后会直接使用动态链接库的代码，通常是常用的第三方模块，模块不升级，动态链接库就不需要升级")]),v._v(" "),a("p",[a("code",[v._v("webpack.DllPlugin")]),v._v(" 和 "),a("code",[v._v("webpack.DllReferencePlugin")])]),v._v(" "),a("p",[a("code",[v._v("DllPlugin")]),v._v(" 中的 "),a("code",[v._v("name")]),v._v(" 参数必须和 "),a("code",[v._v("output.library")]),v._v(" 中保持一致，"),a("code",[v._v("name")]),v._v(" 会影响输出的 "),a("code",[v._v("manifest.json")]),v._v(" 中的 "),a("code",[v._v("name")]),v._v(" 字段的值，"),a("code",[v._v("DllReferencePlugin")]),v._v(" 会去读取 "),a("code",[v._v("manifest.json")]),v._v(" 中的 "),a("code",[v._v("name")]),v._v(" 字段，把值的内容作为从全局变量中获取动态链接库中内容的全局变量名")]),v._v(" "),a("h2",{attrs:{id:"happypack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#happypack"}},[v._v("#")]),v._v(" HappyPack")]),v._v(" "),a("p",[v._v("文件数量变多后，webpack 构建速度会变慢。运行在 Node.js 上的 webpack 是单线程的，需要处理的事情只能一件一件的做")]),v._v(" "),a("p",[v._v("HappyPack 把任务分解成多个子进程并发执行，子进程处理完后再交给主进程。")]),v._v(" "),a("blockquote",[a("p",[v._v("由于 JS 是单线程模型，要发挥多个 CPU 威力，只能通过多进程")])]),v._v(" "),a("ul",[a("li",[v._v("将所有文件的处理都交给 "),a("code",[v._v("HappyPack/loader")]),v._v("，"),a("code",[v._v("?id='babel'")]),v._v(" 告诉 "),a("code",[v._v("HappyPack")]),v._v(" 使用哪个 "),a("code",[v._v("HappyPack实例")]),v._v(" 来处理")]),v._v(" "),a("li",[a("code",[v._v("Plugin")]),v._v(" 配置中新增 "),a("code",[v._v("HappyPack")]),v._v(" 实例告诉 "),a("code",[v._v("HappyPack/loader")]),v._v(" 如何处理文件，"),a("code",[v._v("id")]),v._v(" 与上面对应，选项中的 "),a("code",[v._v("loaders")]),v._v(" 属性和之前一致")])]),v._v(" "),a("p",[v._v("可以开启多个子进程，默认为 3 个，多个 HappyPack 可以共享一个进程池，避免资源占用过多")]),v._v(" "),a("p",[v._v("原理：")]),v._v(" "),a("ul",[a("li",[v._v("webpack 构建中最耗时的是 loader 对文件对转换操作，因为文件数多只能一个一个处理，HappyPack 核心原理是把这部分任务分解到多个进程去并行处理，从而减少总构建时间")]),v._v(" "),a("li",[v._v("核心调度器的代码在主进程中，也就是运行 webpack 进程中，核心调度器会把任务分配给空闲的子进程，处理完毕后发送给核心调度器，之间的数据交换通过进程间通信 API 实现")]),v._v(" "),a("li",[v._v("核心调度器收到子进程处理完毕结果后会通知 webpack 文件处理完毕")])]),v._v(" "),a("h2",{attrs:{id:"paralleluglifyplugin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paralleluglifyplugin"}},[v._v("#")]),v._v(" ParallelUglifyPlugin")]),v._v(" "),a("p",[v._v("压缩代码需要把代码解析成用 Object 表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致计算量大，耗时多")]),v._v(" "),a("p",[a("code",[v._v("ParallelUglifyPlugin")]),v._v(" 会开启多个子进程，把对多个文件的压缩分配给多个子进程，变成了并行执行，更快的对多个文件进行压缩")]),v._v(" "),a("h2",{attrs:{id:"文件监听"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件监听"}},[v._v("#")]),v._v(" 文件监听")]),v._v(" "),a("p",[v._v("原理：")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("定时获取该文件的最后编辑时间，每次都存下最后编辑时间，发现当前获取时间与保存的最后编辑时间不一致时，则认为发生了修改，"),a("code",[v._v("watchOptions.poll")]),v._v(" 用于控制定时检查周期")])]),v._v(" "),a("li",[a("p",[v._v("认为发生变化后，不会立即告诉监听者，而是先缓存起来，收集一段时间的变化后再一次性告诉监听者，"),a("code",[v._v("watchOptions.aggregateTime")]),v._v(" 用于配置等待时间")])]),v._v(" "),a("li",[a("p",[v._v("由于保存文件的路径和最后编辑时间需占用内存，定时检查会占用 CPU 和文件 I/O，所以最好减少需要监听的文件的数量和降低检查频率")])]),v._v(" "),a("li",[a("p",[v._v("可以忽略到 node_modules 的文件，不去监听它们")])]),v._v(" "),a("li",[a("p",[a("code",[v._v("watchOptions.poll")]),v._v(" 越小越好，降低检查频率")])]),v._v(" "),a("li",[a("p",[a("code",[v._v("watchOptions.aggregateTime")]),v._v(" 越大越好，降低重新构建频率")])])]),v._v(" "),a("p",[v._v("但会感觉到监听模式的反应和灵敏度降低了")]),v._v(" "),a("h2",{attrs:{id:"自动刷新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动刷新"}},[v._v("#")]),v._v(" 自动刷新")]),v._v(" "),a("p",[v._v("webpack 负责监听模块，webpack-dev-server 负责刷新浏览器")]),v._v(" "),a("p",[v._v("原理，有三种方法：")]),v._v(" "),a("ol",[a("li",[v._v("借助浏览器扩展去通过浏览器 API 刷新")]),v._v(" "),a("li",[v._v("往开发的网页中注入代理客户端，通过代理客户端去刷新")]),v._v(" "),a("li",[v._v("把要开发的网页装进 iframe 中，通过刷新 iframe 来达到效果")])]),v._v(" "),a("p",[v._v("DevServer 支持后两种，第 2 种是默认方法")]),v._v(" "),a("p",[a("code",[v._v("devServer.inline")]),v._v(" 控制是否注入代理客户端，默认为 "),a("code",[v._v("true")]),v._v(" 表示会注入，每个 chunk 都会注入代理客户端代码，因为不知道网页依赖了哪几个 chunk，就都注入了，会导致构建变慢，可以关闭 "),a("code",[v._v("inline")]),v._v("，则需要通过 "),a("code",[v._v("localhost: 8000/webpack-dev-server")]),v._v(" 来访问项目，网页被装进了 iframe 中，也可以手动注入 "),a("code",[v._v('<script src="http://localhost:8080/webpack-dev-server.js"><\/script>')]),v._v(" 代理客户端脚本")]),v._v(" "),a("h2",{attrs:{id:"模块热替换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块热替换"}},[v._v("#")]),v._v(" 模块热替换")]),v._v(" "),a("p",[v._v("不刷新网页的情况下做到实时预览，原理是当一个模块变化时，只重新编译变化的模块，再用重新输出的新模块替换老模块")]),v._v(" "),a("p",[v._v("原理：")]),v._v(" "),a("p",[v._v("与自动刷新相似，需要往网页注入一个代理客户端用于连接 DevServer 和网页")]),v._v(" "),a("p",[v._v("当模块发生更新时，更新事件会一层一层往上传递，直到有某层接收了当前变化的模块，如果事件一直往上抛到最外层都没有文件接收它，就会直接刷新网页")]),v._v(" "),a("p",[v._v("要优化模块热替换，与自动刷新一样，监听更少的文件，忽略掉 "),a("code",[v._v("node_modules")]),v._v(" 下的文件，模块热替换的运行依赖在每个 chunk 中，都包含代理客户端代码，不能手动关闭 "),a("code",[v._v("inline")]),v._v(" 手动注入代理客户端。")]),v._v(" "),a("h2",{attrs:{id:"区分环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区分环境"}},[v._v("#")]),v._v(" 区分环境")]),v._v(" "),a("p",[v._v("开发环境和生产环境差异包括：")]),v._v(" "),a("ul",[a("li",[v._v("代码压缩")]),v._v(" "),a("li",[v._v("提示开发者的提示日志")]),v._v(" "),a("li",[v._v("开发时所连接的后端数据接口地址和线上环境不同")])]),v._v(" "),a("p",[v._v("当代码中使用了 "),a("code",[v._v("process")]),v._v(" 时 webpack 就自动打包进 process 代码以支持 Node.js 运行环境，这个注入的模块模仿 Node.js 中的 process")]),v._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("DefinePlugin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  "),a("span",{pre:!0,attrs:{class:"token string"}},[v._v("'process.env'")]),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("NODE_ENV")]),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[v._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[v._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[v._v("'production'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br"),a("span",{staticClass:"line-number"},[v._v("2")]),a("br"),a("span",{staticClass:"line-number"},[v._v("3")]),a("br"),a("span",{staticClass:"line-number"},[v._v("4")]),a("br"),a("span",{staticClass:"line-number"},[v._v("5")]),a("br")])]),a("p",[v._v("在定义环境变量时的值使用 "),a("code",[v._v("JSON.stringify")]),v._v(" 包裹字符串的原因是环境变量的值需要一个双引号包裹的字符串")]),v._v(" "),a("p",[v._v("通过 Shell 去定义的环境变量 "),a("code",[v._v("NODE_ENV=production")]),v._v(" webpack 是不认识的，对 webpack 需要处理的代码中的环境区分语句没有作用")]),v._v(" "),a("p",[v._v("同时也可以区分第三方库中的环境区分代码，可以去除一些日志警告")]),v._v(" "),a("p",[a("code",[v._v("NODE_ENV")]),v._v(" 与 "),a("code",[v._v("production")]),v._v(" 为社区约定")]),v._v(" "),a("h2",{attrs:{id:"压缩代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#压缩代码"}},[v._v("#")]),v._v(" 压缩代码")]),v._v(" "),a("p",[v._v("浏览器从服务器访问网页时获取的 JS、CSS 都是文本，文件越大加载时间越长、为了提升网页加载速度和减少网络传输流量，可以对资源进行压缩，除了通过 Gzip 算法压缩外，还可以对文本本身进行压缩")]),v._v(" "),a("h3",{attrs:{id:"压缩-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#压缩-js"}},[v._v("#")]),v._v(" 压缩 JS")]),v._v(" "),a("ul",[a("li",[v._v("提升加载速度")]),v._v(" "),a("li",[v._v("混淆源码，使可读性变差，不利于他人分析代码")])]),v._v(" "),a("p",[v._v("策略：")]),v._v(" "),a("ul",[a("li",[v._v("不生成 sourceMap，开启时耗时大大增加")]),v._v(" "),a("li",[v._v("输出可读性较差代码")]),v._v(" "),a("li",[v._v("移除注释")]),v._v(" "),a("li",[v._v("移除删除代码时的警告输出语句")]),v._v(" "),a("li",[v._v("剔除 console 语句，兼容 IE")]),v._v(" "),a("li",[v._v("内嵌定义了只使用了一次的变量")]),v._v(" "),a("li",[v._v("提取多次使用没有定义为变量的静态值")])]),v._v(" "),a("h3",{attrs:{id:"压缩-css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#压缩-css"}},[v._v("#")]),v._v(" 压缩 CSS")]),v._v(" "),a("p",[v._v("可以提升加载速度和混淆源码，可使用 "),a("code",[v._v("cssnano")])]),v._v(" "),a("h2",{attrs:{id:"cdn-加速"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cdn-加速"}},[v._v("#")]),v._v(" CDN 加速")]),v._v(" "),a("p",[v._v("可以通过压缩来减小网络传输大小，最影响用户体验的是首屏加载速度，导致这个问题是因为网络传输耗时大，CDN 的作用就是加快网络传输")]),v._v(" "),a("p",[v._v("把资源遍布世界各地，在访问时按就近加载原则从离用户最近的服务器获取资源")]),v._v(" "),a("p",[v._v("做法：")]),v._v(" "),a("ul",[a("li",[v._v("针对 HTML 文件，不把 HTML 文件放到 CDN 上，放到自己服务器，同时关闭自己服务器的缓存。自己的服务器只提供 HTML 和数据接口")]),v._v(" "),a("li",[v._v("静态资源 JS、CSS、图片等文件，开启 CDN 和缓存，给每个文件带上唯一的 hash 值，文件名随着文件的变化而变化，只要文件变化 url 就会变化，即使有缓存，也会重新获取")])]),v._v(" "),a("p",[v._v("浏览器针对同一时刻同一域名的并行请求有限制，如果资源过多会阻塞加载，可以把不同资源放到不同的 CDN 服务器上去，过多域名会增加域名解析时间，根据需要权衡得失")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("output.publicPath")]),v._v(" 中设置 JS 的地址")]),v._v(" "),a("li",[a("code",[v._v("css-loader.publicPath")]),v._v(" 中设置被 CSS 导入的资源的的地址。")]),v._v(" "),a("li",[a("code",[v._v("WebPlugin.stylePublicPath")]),v._v(" 中设置 CSS 文件的地址")])]),v._v(" "),a("h2",{attrs:{id:"tree-shaking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking"}},[v._v("#")]),v._v(" Tree Shaking")]),v._v(" "),a("p",[v._v("剔除用不上的死代码，依赖静态的 ES6 模块化语法")]),v._v(" "),a("h2",{attrs:{id:"提取公共代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提取公共代码"}},[v._v("#")]),v._v(" 提取公共代码")]),v._v(" "),a("p",[v._v("大型网站有多个页面，每个页面都是单页应用，页面间会有很多同样的代码")]),v._v(" "),a("ul",[a("li",[v._v("相同的资源会被重复加载，浪费流量和服务器成本")]),v._v(" "),a("li",[v._v("每个页面加载资源大，导致首屏加载慢")])]),v._v(" "),a("p",[v._v("好处：")]),v._v(" "),a("ul",[a("li",[v._v("减少网络传输流量，降低成本")]),v._v(" "),a("li",[v._v("虽然第一次加载时得不到优化，但访问其它页面时速度将大大提升")])]),v._v(" "),a("h2",{attrs:{id:"按需加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#按需加载"}},[v._v("#")]),v._v(" 按需加载")]),v._v(" "),a("ul",[a("li",[v._v("将网站的功能划分成一个个小功能，按照功能的相关程度分类")]),v._v(" "),a("li",[v._v("将每一类合为一个 chunk，按需加载对应的 chunk")]),v._v(" "),a("li",[v._v("对于用户首次加载时看到的功能不做按需加载，放到执行入口的 chunk 中，降低用户能感知的网页加载时间")]),v._v(" "),a("li",[v._v("对于个别大量代码的功能点，可再对其进行按需加载")])]),v._v(" "),a("p",[v._v("依赖 "),a("code",[v._v("babel-plugin-syntax-dynamic-import")])]),v._v(" "),a("h2",{attrs:{id:"prepack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prepack"}},[v._v("#")]),v._v(" Prepack")]),v._v(" "),a("p",[v._v("代码的压缩和分块都是在网络加载层面上的，除此之外可以提升运行时的效率")]),v._v(" "),a("p",[v._v("原理：")]),v._v(" "),a("ul",[a("li",[v._v("通过 Babel 把 JS 解析成 AST")]),v._v(" "),a("li",[v._v("Prepack 实现了一个 JS 解析器，用于执行源码，借助这个解析器掌握源码具体如何执行，并返回执行后的输出")])]),v._v(" "),a("h2",{attrs:{id:"scope-hoisting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scope-hoisting"}},[v._v("#")]),v._v(" Scope Hoisting")]),v._v(" "),a("p",[v._v("可以让打包出来的体积更小，运行的更快")]),v._v(" "),a("p",[v._v("分析出各个模块的依赖关系，尽可能把打散的模块合并到一个函数中去，由于需要分析依赖关系，所以需要采用 ES6 模块化语句")]),v._v(" "),a("h2",{attrs:{id:"输出分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输出分析"}},[v._v("#")]),v._v(" 输出分析")]),v._v(" "),a("p",[v._v("需要对输出结果进行分析，以决定下一步优化方向")]),v._v(" "),a("p",[a("code",[v._v("webpack --profile --json > stats.json")]),v._v(" 记录耗时以 JSON 格式输出到 "),a("code",[v._v("stats.json")])]),v._v(" "),a("p",[a("code",[v._v("webpack-bundle-analyzer")])])])}),[],!1,null,null,null);_.default=s.exports}}]);